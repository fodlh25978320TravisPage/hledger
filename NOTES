hledger project notes

"...simplicity of design was the most essential, guiding principle.
Clarity of concepts, economy of features, efficiency and reliability of
implementations were its consequences." --Niklaus Wirth

"The competent programmer is fully aware of the limited size of his own
skull. He therefore approaches his task with full humility, and avoids
clever tricks like the plague." --Edsger Dijkstra

* to do
** errors
*** balance report: zero-balance root accounts do not elide properly
** features
*** actual/effective entry & txn dates, for completeness
*** ~/.hledgerrc, for setting defaults
*** more date syntax: last nov, next friday
*** speed
**** more optimisation
**** speed regression tests
**** cache file ?
*** more ledger features
**** allow - before currency symbol ?
**** support complete period syntax ?
    every N days     # N is any integer
    every N weeks
    every N months
    every N quarters
    every N years
    biweekly
    bimonthly
*** new features
**** allow comment lines immediately after or within an entry
**** accept multiple -f files
**** more reliable tidy layout from print
**** -Q quarterly interval option, for consistency/convenience ?
**** web gui
**** charts
**** easier data entry
**** parse more file formats - gnucash, qif, ofx, csv..
**** parse in-progress timelog entries
**** split day-spanning timelog sessions, don't report more than 24 hours in a day
**** easy timelog queries when called as "hours"
**** i18n
** tests
*** wanted: a test for reading a ledger from stdin
*** test on more ledger files
*** easy ledger compatibility testing
**** --compare to compare (xml?) output with ledger with same args
** docs
*** --version
*** --help
*** readme
**** keep in sync (automate)
***** README file
***** hledger.hs module description
***** hledger.cabal description field (exclude home page link)
***** home page description (http://joyful.com/Hledger/editform)
***** mail list description (http://groups.google.com/groups/hledger -> edit welcome msg)
***** gmane description
***** darcsweb description
*** announcements
**** generate from README and NEWS
*** release notes
**** NEWS
*** implementation docs
*** api docs
*** developer intro
**** style tips
***** we aim to make reliable software:
****** fixes come before features
****** "bugs" get called "errors", as in "the programmer messed up"
****** we test continuously and thoroughly (code, doc & speed tests on each checkin)
****** less is more
*** user manual
*** differences not noted in README
**** ledger shows description comments as part of description
**** ledger seems to get amounts' x-position wrong more than hledger
**** ledger can't parse full smart dates in display expressions
**** hledger print puts a blank line after the entry, not before it
**** ledger can get timelog entry balance wrong, see mail list
**** ledger reports timelog sessions as virtual transactions
** web presence
*** clarify bugtracking process
* misc
** things I want to know
*** time
where have I been spending my time in recent weeks ?
where have I spent my time today ?
what is my status wrt spending plan for this week/month/year ?
what is my current status wrt time spending goals ?
*** money
where have I been spending my money ?
what is my status wrt spending plan for this week/month/year ?
what is my current status wrt spending/savings goals ?
what are all my current balances ?
what does my balance history look like ?
what does my balance future look like ?
are there any cashflow, tax, budgetary problems looming ?
*** charts
[1:27pm] <sm> I have decided I am not getting enough visible day-to-day value out of my ledger, I need more of that to stay motivated
[1:27pm] <Nafai> What do you think will help in that?
[1:27pm] <sm> I think some simple self-updating charts, or even good reports in a visible place
[1:28pm] <sm> something I don't have to spend an hour fiddling with to get answers
[1:38pm] <sm> Nafai: identifying/designing some useful reports/charts seems to be blocking me
[1:39pm] <sm> there are probably some standard ones I should use
[1:40pm] <sm> a graph of daily net worth is probably one of the simplest
[1:58pm] <sm> what else.. a chart of weekly expenses in key categories
[1:58pm] <sm> ditto, monthly
[1:58pm] <sm> a chart of monthly income
[1:59pm] <sm> those three should help me be more clear about cashflow status
[2:00pm] <sm> also I'd like something that shows me how much I am on top of financial tracking - how current my numbers are, when last reconciled etc - at a glance
[2:01pm] <sm> another simple one: current balances in all accounts
[2:01pm] <sm> those would be a great start
[2:04pm] <sm> daily net worth, weekly expense, monthly expense, monthly income, confidence/currentness report, and balance report
[2:05pm] <sm> let's see, which of those 6 would give most payoff right now
[2:05pm] <sm> probably 5
[2:06pm] <sm> how could I measure that ?
[2:06pm] <sm> number of days since last ledger entry..
[2:06pm] <sm> number of ledger entries in last 30 days (compared to average)
[2:07pm] <sm> number of days since last cleared checking entry (indicating an online reconcile)
[2:08pm] <sm> those would be a good start. How do I make those visual
[2:09pm] <sm> well I guess the first step is a script to print them

** compare other languages! a parser generator and decent speed is required
*** python: http://cheeseshop.python.org/pypi/ZestyParser, pysec, pyparsing
*** squeak: LanguageGame, T-Gen, SmaCC
*** lisp: ?
*** ruby: too slow (?)
** data representation
*** http://www.python.org/dev/peps/pep-0327/
*** http://www.n-heptane.com/nhlab/repos/Decimal/
*** http://www.n-heptane.com/nhlab/repos/Decimal/Money.hs
*** http://www2.hursley.ibm.com/decimal/
** lispy's template haskell for quickcheck
-- find tests with template haskell
import Language.Haskell.Parser

{-# OPTIONS_GHC -fno-warn-unused-imports -no-recomp -fth #-}
{- ghc --make Unit.hs -main-is Unit.runTests -o unit -}
runTests :: IO ()
runTests = $(mkChecks props)

mkChecks []        = undefined
mkChecks [name]    = mkCheck name
mkChecks (name:ns) = [| $(mkCheck name) >> $(mkChecks ns) |]

mkCheck name = [| putStr (name ++ ": ") >> quickCheck $(varE (mkName name)) |]

{- | looks in Tests.hs for functions like prop_foo and returns
  the list.  Requires that Tests.hs be valid Haskell98. -}
props :: [String]
props = unsafePerformIO $
  do h <- openFile "Tests.hs" ReadMode
     s <- hGetContents h
     case parseModule s of
       (ParseOk (HsModule _ _ _ _ ds)) -> return (map declName (filter isProp ds))
       (ParseFailed loc s')            -> error (s' ++ " " ++ show loc)

{- | checks if function binding name starts with @prop_@ indicating
 that it is a quickcheck property -}
isProp :: HsDecl -> Bool
isProp d@(HsFunBind _) = "prop_" `isPrefixOf` (declName d)
isProp _ = False

{- | takes an HsDecl and returns the name of the declaration -}
declName :: HsDecl -> String
declName (HsFunBind (HsMatch _ (HsIdent name) _ _ _:_)) = name
declName _                                              = undefined

** snippets
-- trace a MixedAmount
matrace :: MixedAmount -> MixedAmount
matrace a@(Mixed as) = trace (show as) a

-- normalise and trace a MixedAmount
nmatrace :: MixedAmount -> MixedAmount
nmatrace a = trace (show as) a where (Mixed as) = normaliseMixedAmount a

